<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Download</title>
    <style>
        body {
            padding: 20px;
            font-family: monospace;
        }
        #content {
            white-space: pre;
            overflow-x: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 20px;
        }
    </style>
    <body>
        <button onclick="downloadText()">Download Text</button>
        <div id="content"></div>
    
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const textContent = `// Your code \nconsole.log('****************ex5 dsss************
clear all;
%% parameters
Fs = 1000;
fc = 100;
fp = 4;
bit_t = 0.1;
%% message generation with BPSK
m = [0 0 1 1 1 1 0 0];
%% Polar form conversion
for bit = 1:length(m)
    if(m(bit)==0)
    m(bit) = -1;
    end
end
%% Oversampling (4)
message = repmat(m,1,fp); 
%% PN generation and multiply with message
pn_code = randi([0,1],1,length(message));
%% Polar form PN 
for bit = 1:length(pn_code)
    if(pn_code(bit)==0)
    pn_code(bit) = -1;
    end
end
DSSS = message.*pn_code;
%% create carrier and multipy with encoded sequence
t = 0:1/Fs:(bit_t-1/Fs);
s0 = -1*cos(2*pi*fc*t);
s1 = cos(2*pi*fc*t);
carrier = [];
BPSK = [];
for i = 1:length(DSSS)
if (DSSS(i) == 1)
    BPSK = [BPSK s1];
elseif (DSSS(i) == -1)
    BPSK = [BPSK s0];
end
    carrier = [carrier s1];
end
%% demodulation
rx =[];
for i = 1:length(pn_code)
if(pn_code(i)==1)
    rx = [rx BPSK((((i-1)*length(t))+1):i*length(t))];
else
    rx = [rx (-1)*BPSK((((i-1)*length(t))+1):i*length(t))];
end
end
demod = rx.*carrier;
result = [];
for i = 1:length(m)
x = length(t)*fp;
cx = sum(carrier(((i-1)*x)+1:i*x).*demod(((i-1)*x)+1:i*x));
if(cx>0)
    result = [result 1];
else
    result = [result -1];
end
end
pn_codeWrong = randi([0,1],1,length(m)*fp);
resultWrong = [];
rx2 =[];
for i = 1:length(pn_code)
if(pn_codeWrong(i)==1)
    rx2 = [rx2 BPSK((((i-1)*length(t))+1):i*length(t))];
else
    rx2 = [rx2 (-1)*BPSK((((i-1)*length(t))+1):i*length(t))];
end
end
demod2 = rx2.*carrier;
for i = 1:length(m)
x = length(t)*fp;
cx = sum(carrier(((i-1)*x)+1:i*x).*demod2(((i-1)*x)+1:i*x));
if(cx>0)
    resultWrong = [resultWrong 1];
else
    resultWrong = [resultWrong -1];
end
end
message1 = repmat(result,fp,1);
message1 = reshape(message1,1,[]);
message2 = repmat(resultWrong,fp,1);
message2 = reshape(message2,1,[]);
%% Draw original message, PN code , encoded sequence on time domain
pn_size = length(pn_code);
tpn = linspace(0,length(m)*bit_t-bit_t/fp,pn_size);
tm = 0:bit_t/fp:length(m)*bit_t-bit_t/fp;
figure
subplot(311)
stairs(tm,message,'linewidth',2)
title('Message bit sequence')
axis([0 length(m)*bit_t -1 1]);
subplot(312)
stairs(tpn,pn_code,'linewidth',2)
title('Pseudo-random code');
axis([0 length(m)*bit_t -1 1]);
subplot(313)
stairs(tpn,DSSS,'linewidth',2)
title('Modulated signal');
axis([0 length(m)*bit_t -1 1]);
figure
subplot(311)
stairs(tm,message,'linewidth',2)
title('Message bit sequence')
axis([0 length(m)*bit_t -1 1]);
subplot(312)
stairs(tm,message1,'linewidth',2)
title('Received message using true pseudo-random code')
axis([0 length(m)*bit_t -1 1]);
subplot(313)
stairs(tm,message2,'linewidth',2)
title('Received message using wrong pseudo-random code')
axis([0 length(m)*bit_t -1 1]);
%% Draw original message, PN code , encoded sequence on frequency domain
f = linspace(-Fs/2,Fs/2,1024);
figure
subplot(311)
plot(f,abs(fftshift(fft(message,1024))),'linewidth',2);
title('Message spectrum')
subplot(312)
plot(f,abs(fftshift(fft(pn_code,1024))),'linewidth',2);
title('Pseudo-random code spectrum');
subplot(313)
plot(f,abs(fftshift(fft(DSSS,1024))),'linewidth',2);
title('Modulated signal spectrum');
figure;
subplot(311)
plot(f,abs(fftshift(fft(BPSK,1024))),'linewidth',2);
title('Transmitted signal spectrum');
subplot(312)
plot(f,abs(fftshift(fft(rx,1024))),'linewidth',2);
title('Received signal multiplied by pseudo code');
subplot(313)
plot(f,abs(fftshift(fft(demod,1024))),'linewidth',2);
title('Demodulated signal spectrum before decision device ');


**********************e5 fhss********************
clc; clear all;% Parameters
num_bits = 20; % Number of bits
samples_per_bit = 120; % Samples per bit
num_carriers = 6; % Number of carrier frequencies
samples = [10, 20, 30, 40, 60, 120]; % Samples for each carrier frequency
% Manual Entry of Bit Sequence
disp('Enter your bit sequence as a series of 1s and 0s separated by spaces (e.g., "1 0 1 1 0"):');
manual_input = input('', 's'); % Take input as a string
bit_sequence = str2num(manual_input); % Convert to numeric array
if length(bit_sequence) ~= num_bits
error('The number of bits entered must match the defined number of bits (%d).', num_bits);
end
% Convert 0 -> -1, 1 -> +1 for BPSK
sequence = 2 * bit_sequence - 1;
% Repeat bits for the bit duration
input_signal = repelem(sequence, samples_per_bit); % Repeat for bit duration
% Generate Carrier Signal with Exact Length
t_carrier = linspace(0, 2*pi*num_bits, samples_per_bit*num_bits); % Time vector
carrier_signal = cos(t_carrier); % Continuous cosine carrier wave
% Plot Original Bit Sequence
figure(1);
subplot(4,1,1); plot(input_signal); axis([-100 2400 -1.5 1.5]);
title('\bf\it Original Bit Sequence');
% BPSK Modulation
bpsk_mod_signal = input_signal .* carrier_signal;
subplot(4,1,2); plot(bpsk_mod_signal); axis([-100 2400 -1.5 1.5]);
title('\bf\it BPSK Modulated Signal');
% Generate 6 Carrier Frequencies
carriers = cell(1, num_carriers);
for i = 1:num_carriers
t = linspace(0, 2*pi, samples(i) + 1); t(end) = []; % Time for each carrier
carriers{i} = repmat(cos(t), 1, ceil(samples_per_bit / length(t)));
carriers{i} = carriers{i}(1:samples_per_bit); % Trim to exact length
end
% Spread Signal with Random Carrier Frequencies
spread_signal = [];
for i = 1:num_bits
carrier_idx = randi([1, num_carriers]); % Randomly select a carrier
spread_signal = [spread_signal carriers{carrier_idx}];
end
subplot(4,1,3); plot(spread_signal); axis([-100 2400 -1.5 1.5]);
title('\bf\it Spread Signal with 6 frequencies');
% Spreading BPSK Signal
freq_hopped_sig = bpsk_mod_signal .* spread_signal;
subplot(4,1,4); plot(freq_hopped_sig); axis([-100 2400 -1.5 1.5]);
title('\bf\it Frequency Hopped Spread Spectrum Signal');
% Demodulation
bpsk_demodulated = freq_hopped_sig ./ spread_signal;
figure(2);
subplot(2,1,1); plot(bpsk_demodulated); axis([-100 2400 -1.5 1.5]);
title('\bf Demodulated BPSK Signal from Wide Spread');
% Recover Original Bit Sequence
original_BPSK_signal = bpsk_demodulated ./ carrier_signal;
subplot(2,1,2); plot(original_BPSK_signal); axis([-100 2400 -1.5 1.5]);
title('\bf Transmitted Original Bit Sequence');


*********************************ex6 symbol****************
L        = 4;         % Oversampling factor
rollOff  = 0.5;       % Pulse shaping roll-off factor
rcDelay  = 10;  
% Filter:
htx = rcosdesign(rollOff, 6, 4);
% Note half of the target delay is used, because when combined
% to the matched filter, the total delay will be achieved.
hrx  = conj(fliplr(htx));
p = conv(htx,hrx);
M = 2; % PAM Order

% Arbitrary binary sequence alternating between 0 and 1
data = zeros(1, 2*rcDelay);
data(1:2:end) = 1;

% PAM-modulated symbols:
txSym = real(pammod(data, M));

% Upsampling
txUpSequence = upsample(txSym, L);

% Pulse Shaping
txSequence = filter(htx, 1, txUpSequence);

%Delay in channel  random channel propagation delay in units of sampling intervals (not symbol intervals)
timeOffset = 1; % Delay (in samples) added
% Delayed sequence
rxDelayed = [zeros(1, timeOffset), txSequence(1:end-timeOffset)];

% Received sequence with Delayed
mfOutput = filter(hrx, 1, rxDelayed); % Matched filter output

rxSym = downsample(mfOutput, L);
% Generate a vector that shows the selected samples
selectedSamples = upsample(rxSym, L);
selectedSamples(selectedSamples == 0) = NaN;

% scatter plot
figure
plot(complex(rxSym(rcDelay+1:end)), 'o')
grid on
xlim([-1.5 1.5])
title('Rx Scatterplot')
xlabel('In-phase (I)')
ylabel('Quadrature (Q)')

figure
stem(rxSym)
title('Symbol Sequence with delay')
xlabel('Symbol Index')
ylabel('Amplitude')

%Symbol timing recovery
rxSym = downsample(mfOutput, L, timeOffset);

selectedSamples = upsample(rxSym, L);
selectedSamples(selectedSamples == 0) = NaN;

figure
plot(complex(rxSym(rcDelay+1:end)), 'o')
grid on
xlim([-1.5 1.5])
title('Rx Scatterplot')
xlabel('In-phase (I)')
ylabel('Quadrature (Q)')

figure
stem(rxSym)
title('Symbol Sequence without delay')
xlabel('Symbol Index')
ylabel('Amplitude')


**************************************ex7 fre select***********************
clc;clear all;close all;
fs = 1e6;                   % Sample rate (1 MHz)
numSamples = 10000;          % Number of samples
numPaths = 5;                % Number of multipath components
maxDelay = 3e-6;             % Maximum delay spread (3 microseconds)
dopplerShift = 100;          % Maximum Doppler shift (100 Hz)
% Generate an impulse signal (delta function)
impulseSignal = [1; zeros(numSamples-1, 1)];  % An impulse signal
% Create a frequency-selective Rayleigh fading channel
rayleighChan = comm.RayleighChannel( ...
    'SampleRate', fs, ...
    'PathDelays', linspace(0, maxDelay, numPaths), ...  % Multipath delays
    'AveragePathGains', [-2 -3 -6 -8 -10], ...          % Path gains (dB)
    'MaximumDopplerShift', dopplerShift, ...            % Doppler shift
    'NormalizePathGains', true);
% Pass the impulse signal through the frequency-selective fading channel
rxImpulseSignal = rayleighChan(impulseSignal);
% Plot the impulse response
timeAxis = (0:numSamples-1)/fs;  % Time axis for plotting
figure;
stem(timeAxis(1:100), 20*log10(abs(rxImpulseSignal(1:100))));  % Plot first 100 samples in dB
title('Impulse Response of Frequency-Selective Rayleigh Fading Channel');
xlabel('Time (s)');ylabel('Gain (dB)');grid on;
% Frequency Response
NFFT = 1024;  % FFT size for frequency response
freqResponse = fft(rxImpulseSignal, NFFT);  % FFT of the received impulse signal
freqAxis = linspace(-fs/2, fs/2, NFFT);  % Frequency axis
% Plot the frequency response
figure;
plot(freqAxis/1e6, 20*log10(abs(fftshift(freqResponse))));  % Shift zero frequency to center
title('Frequency Response of Frequency-Selective Rayleigh Fading Channel');
xlabel('Frequency (MHz)');ylabel('Magnitude (dB)');grid on;


*****************************************ex7 freq non select******************
clc;clear all;close all
fs = 1e6;                   % Sample rate (1 MHz)
numSamples = 10000;         % Number of samples
maxDopplerShift = 100;      % Maximum Doppler shift (100 Hz)


% Generate random data signal (complex baseband)
txSignal = (randn(numSamples, 1) + 1j*randn(numSamples, 1));  % Complex Gaussian signal
% Create flat Rayleigh fading channel
rayleighChan = comm.RayleighChannel( ...
    'SampleRate', fs, ...
    'MaximumDopplerShift', maxDopplerShift, ... % Doppler shift
    'NormalizePathGains', true);                % Normalize path gains
% Pass the signal through the flat Rayleigh fading channel
rxSignal = rayleighChan(txSignal);
% Plot the transmitted and received signals (first 100 samples)
figure;subplot(2, 1, 1);
plot(real(txSignal(1:100)), 'b-o');hold on;
plot(imag(txSignal(1:100)), 'r-x');
title('Transmitted Signal (First 100 Samples)');
xlabel('Sample Index');ylabel('Amplitude');
legend('Real Part', 'Imaginary Part');grid on;
subplot(2, 1, 2);
plot(real(rxSignal(1:100)), 'b-o');hold on;
plot(imag(rxSignal(1:100)), 'r-x');
title('Received Signal through Flat Rayleigh Fading Channel (First 100 Samples)');
xlabel('Sample Index');ylabel('Amplitude');
legend('Real Part', 'Imaginary Part');grid on;
% Compute and plot the power spectral density (PSD) of the transmitted and received signals
figure;
pwelch(txSignal, [], [], [], fs, 'centered');hold on;
pwelch(rxSignal, [], [], [], fs, 'centered');
title('Power Spectral Density (PSD) of Transmitted and Received Signals');
xlabel('Frequency (Hz)');ylabel('Power/Frequency (dB/Hz)');
legend('Transmitted Signal', 'Received Signal');grid on;


***********************************ex 8 carrier*****************************

% Step 1: Define Basic Parameters
Fs = 10000;               % Sampling frequency (Hz)
Ts = 1 / Fs;              % Sampling period (s)
symbolRate = 1000;        % Symbol rate (symbols per second)
L = 4;                    % Oversampling factor (samples per symbol)
rollOff = 0.5;            % Roll-off factor for pulse shaping filter
rcDelay = 10;             % Filter delay

% Channel properties (Multipath)
numPaths = 4;             % Number of paths in the channel
pathDelays = [0 1 3 6] * Ts;   % Path delays (in seconds)
pathGains = (1/sqrt(2)) * (randn(numPaths, 1) + 1j * randn(numPaths, 1)); % Rayleigh fading coefficients (complex)

% Display the parameters
disp('Signal Properties:');
disp(['Sampling Frequency (Fs): ', num2str(Fs), ' Hz']);
disp(['Symbol Rate: ', num2str(symbolRate), ' symbols/sec']);
disp(['Oversampling Factor (L): ', num2str(L)]);
disp(' ');

disp('Channel Properties:');
disp(['Number of Paths: ', num2str(numPaths)]);
disp('Path Delays (in samples):');
disp(round(pathDelays * Fs));  % Convert delay to samples
disp('Path Gains (complex):');
disp(pathGains);

% Step 2: Generate Test Signal (BPSK)
numBits = 1000;           % Number of bits
data = randi([0 1], numBits, 1);  % Generate random binary sequence
txSymbols = 2*data - 1;  % BPSK modulation: 0 -> -1, 1 -> +1

% Pulse shaping (Raised Cosine Filter)
htx = rcosdesign(rollOff, 6, L);   % Raised cosine filter with rolloff factor
txUpSequence = upsample(txSymbols, L);  % Upsample the modulated signal
txSignal = filter(htx, 1, txUpSequence);  % Apply the raised cosine filter for pulse shaping

% Step 3: Create Frequency-Selective Rayleigh Fading Channel
rayleighChannel = comm.RayleighChannel( ...
    'SampleRate', Fs, ...                % Sampling rate
    'PathDelays', pathDelays, ...        % Path delays in seconds
    'AveragePathGains', [10*log10(abs(pathGains).^2)]', ... % Average path gains in dB
    'MaximumDopplerShift', 0, ...        % Maximum Doppler shift
    'NormalizePathGains', true, ...      % Normalize path gains
    'PathGainsOutputPort', true);       % Fading profile (Nakagami fading model)

% Step 4: Pass the Signal Through the Frequency-Selective Fading Channel
rxSignalFading = rayleighChannel(txSignal);  % Faded signal received at the receiver

% Step 5: Visualize the Results - Compare Transmitted and Received Signals

% Plot the transmitted signal (before fading)
figure;
subplot(3,1,1);
plot(real(txSignal(1:100)), 'g');
title('Transmitted Signal (Real Part)');
xlabel('Sample Index');
ylabel('Amplitude');
grid on;

% Plot the received signal (after fading)
subplot(3,1,2);
plot(real(rxSignalFading(1:100)), 'b');
title('Received Signal (Real Part) after Frequency-Selective Fading');
xlabel('Sample Index');
ylabel('Amplitude');
grid on;

% Optionally, add AWGN noise to simulate real-world noisy conditions
SNR = 10;  % Signal-to-noise ratio in dB
rxSignalNoisy = awgn(rxSignalFading, SNR, 'measured');  % Add AWGN noise

% Plot the received noisy signal
subplot(3,1,3);
plot(real(rxSignalNoisy(1:100)), 'r');
title('Received Noisy Signal (Real Part)');
xlabel('Sample Index');
ylabel('Amplitude');
grid on;

% Optionally, visualize the effect on the constellation diagram
% Plot the constellation of the transmitted signal (ideal)
figure;
subplot(2,1,1);
scatter(real(txSignal(1:100)), imag(txSignal(1:100)), 'g');
title('Transmitted Signal Constellation');
xlabel('In-phase');
ylabel('Quadrature');
grid on;

% Plot the constellation of the received signal after fading
subplot(2,1,2);
scatter(real(rxSignalFading(1:100)), imag(rxSignalFading(1:100)), 'b');
title('Received Signal Constellation after Frequency-Selective Fading');
xlabel('In-phase');
ylabel('Quadrature');
grid on;

% If noise was added, plot the constellation of the noisy received signal
figure;
scatter(real(rxSignalNoisy(1:100)), imag(rxSignalNoisy(1:100)), 'r');
title('Received Noisy Signal Constellation');
xlabel('In-phase');
ylabel('Quadrature');
grid on;
*******************************');`;
document.getElementById('content').textContent = textContent;


            const blob = new Blob([textContent], { type: "text/plain" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "code.txt";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
    </script>
</head>
</body>
    

</html>
